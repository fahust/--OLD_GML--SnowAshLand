<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1000</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ini_open("savefile.ini");//to open our file
decrypted11 = ini_read_string ("player","time","SUFW^");
     time2 = XOR_CryptString( string(decrypted11), "bahamut");
    var time = real(time2)
            red = ini_read_real ("player","red",0);
        green = ini_read_real ("player","green",0);
        blue = ini_read_real ("player","blue",0);
        ini_close();
        global.sl_time = time


        
// MUST HAVE: Create a surface for drawing all the lights
//sur = surface_create(view_wview, view_hview);
sur = surface_create(room_width, room_height);
m = instance_create(0, 0, obj_lightlow);
with (m) {
  light_change_scale(4, 4);
  // Update the light, so it's surface is drawn correctly
  light_update();
}
/*
red = 235 //A SAVE
green = 235 //A SAVE
blue = 235 //A SAVE
*/

//usize = shader_get_uniform(shader,"size");//uniform for width, height, radius
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//surface_free(sur);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with (obj_lightlow){
light_change_scale(3, 3);
  light_update();}
  
  /*if not surface_exists(sur){
//sur = surface_create(room_width, room_height);
sur = surface_create(view_wview, view_hview);
}
//alarm[0] = 10
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Update one light to follow the mouse


if instance_exists(obj_lightlow){
with (obj_lightlow){
if point_distance(x,y,obj_controllerplayer.x,obj_controllerplayer.y) &lt; 2000 {
  light_update();}}
}


/*if instance_exists(m){
m.x = mouse_x;
m.y = mouse_y;

// Update this light to draw the correct shadows
with (m)
  light_update();}else{
  m = instance_create(0, 0, obj_lightlow);
with (m) {
  light_change_scale(4, 4);
  // Update the light, so it's surface is drawn correctly
  light_update();
}
  
  }*/
  
  /*// Update one light to follow the mouse
if surface_exists(sur){
global.sl_time += 0.0002
if global.sl_time &gt; 24 {
global.sl_time = 0
}
if instance_exists(m){
m.x = obj_zombie.x;
m.y = obj_zombie.y;


// Update this light to draw the correct shadows
//with (m)
//  light_update();
  
  }
  }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if surface_exists(sur){
surface_set_target(sur);
draw_clear(c_black);
draw_set_blend_mode(bm_add);
with (obj_lightlow) {
if surface_exists(sur){
  draw_surface_ext(sur, x - sprite_width / 2, y - sprite_height / 2, 1, 1, 0, image_blend, 1);
}else{
sur = surface_create(sprite_width, sprite_height);
}

}
draw_set_blend_mode(bm_normal);
surface_reset_target();
}
/*
// MUST HAVE: Draw all the lights to the surface
surface_set_target(sur);

if not instance_exists(m) &amp;&amp; obj_zombie.torch = true {

m = instance_create(obj_zombie.x, obj_zombie.y, obj_lightlow);
with (m) {
torch = 1
  light_change_scale(3 ,3);
  // Update the light, so it's surface is drawn correctly
  light_update();
}
}




//NUIT TOMBE
if global.sl_time &gt; 16  {
if red &gt; 1 {
red -= 0.005
green -= 0.005
}else{

}
if blue &gt; 1 {
blue -= 0.005
}
}
//REMONTER DU JOUR
if global.sl_time &lt; 12{
if red &lt; 235 {
red += 0.005
green += 0.005
}else{

}
if blue &lt; 235 {
blue += 0.005
}
}
  colorfond = make_color_rgb(red, green, blue);
   
//if global.interieur = 1 {
if global.interieur = 1 {
draw_clear(c_black);//couleur du fond

}else{
draw_clear(colorfond);//couleur du fond
}
//}else{
//draw_clear(couleurheure)
//}
if surface_exists(sur){
draw_set_blend_mode(bm_add);
with (obj_lightlow) {
if torch = 1 {
  draw_surface_ext(sur, x - view_xview - sprite_width / 2, y - view_yview - sprite_height / 2, 1, 1, 0, image_blend, 1);
 }else{
   draw_surface_ext(sur, x - view_xview - sprite_width / 2, y - view_yview - sprite_height / 2, 1, 1, 0, image_blend, 1);
}}
draw_set_blend_mode(bm_normal);




surface_reset_target();

//PEUT ETRE A ENLEVER AVAHT DAHS EHD STEP
// Update this light to draw the correct shadows
with (m)
  light_update();

}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="50">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Create a light on mouse position
/*with (instance_create(mouse_x, mouse_y, obj_lightlow)) {
  image_blend = make_color_rgb(200 + irandom(55), 200 + irandom(55), 200 + irandom(55));
  light_change_scale(2, 2);
  light_update();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if surface_exists(sur) {

    surface_set_target(sur);
        draw_clear_alpha(c_white, 0);
    surface_free(sur);
    surface_reset_target();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Create a light
if surface_exists(sur) {

    surface_set_target(sur);
        draw_clear_alpha(c_white, 0);
    surface_free(sur);
    surface_reset_target();
}

alarm[0] = 5



//RESIZE
/*
surface_set_target(sur);
if room_width != surface_get_width(application_surface) || room_height != surface_get_height(application_surface)
   {
   surface_resize(application_surface, room_width,room_height);
   }
   
   surface_reset_target();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// MUST HAVE: Draw the surface to the screen
// MUST HAVE: Draw the surface to the screen
if surface_exists(sur){
draw_set_blend_mode_ext(bm_dest_color, bm_zero);
draw_surface_ext(sur, 0, 0, 1, 1, 0, c_white, 1);
draw_set_blend_mode(bm_normal);

// Draw info
draw_set_color(c_white);
draw_text(view_xview, view_yview, string(fps) + "fps#" + string(instance_number(obj_lightlow)) + " lights#" + string(instance_number(obj_wall)) + " casters");
draw_set_color(c_black);
}else{
sur = surface_create(room_width, room_height);
}


/*if surface_exists(sur){



draw_set_blend_mode_ext(bm_dest_color, bm_zero);
draw_surface_ext(sur, view_xview, view_yview, 1, 1, 0, c_white, 1);// 0 0
//draw_surface(sur,view_xview,view_yview)
draw_set_blend_mode(bm_normal);


//draw_set_blend_mode_ext(bm_dest_color, bm_zero);
//shader_set(shader);
   // shader_set_uniform_f(usize,1370,900,8)//width,height,radius
//surface_copy(sur,0,0,application_surface)
//draw_surface_ext(sur, view_xview, view_yview, 1, 1, 0, c_white, 1);
//shader_reset();
//draw_set_blend_mode(bm_normal);


// Draw info
draw_set_color(c_white);



draw_set_font(fnt_cool);
    draw_set_color(c_white);
    draw_set_halign(fa_center);
    draw_set_alpha(1);
     yy=20
    draw_text(view_xview[view_current]+1250,view_yview[view_current]+yy,string(global.sl_time-frac(global.sl_time))+"h "+string(floor(60*frac(global.sl_time))));
    draw_set_alpha(1);
    draw_set_color(c_black);




//draw_text(0, 0, string(fps) + "fps#" + string(instance_number(obj_lightlow)) + " lights#" + string(instance_number(obj_wall)) + " casters");
//draw_set_color(c_black);


//draw_background(neige7, 0, 0);



}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
